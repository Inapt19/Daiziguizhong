## 前言

在Leetcode上面，看到了[Shortest Subarray with Sum at Least K][1]这题。想了半天也没个答案 。

后来在微信群里，@phoooooooooooolos 老哥给了一套[单调队列优化的题目][2]。

这里想把做题当中遇到的问题分享一下。

## A题、B题

这两题都是比较裸的区间最大（最小）值统计的题目。

对于这种题目，我们可以使用`multiset<int>`或者RMQ来做，相对来说比较好想。如果时限和空间卡的不是太严格的话，我甚至推荐用这种简单粗暴的方法。

使用单调队列的话，我们需要考虑队列中存什么、怎么存。单调队列中，我们维护的是一组单调的值。这是的单调有两层意思：

* 元素的时序从队首到队尾，按照新旧排列
* 无素的值是按照值的大小，依次排列（可升序可降序，根据题目要求决定）

以A题中，求滑动窗口的最大值为例。队尾存储的是当前滑动窗口下的最大值，由于滑动窗口持续向右移动，所以此最大值右边的任意值都是没有意义的。而队首存储是当前的值，因为我们在后续的统计中，我们不知道当前的值是否是最大的，我们需要将这个值放在队列中。

所以伪代码如下，顺序遍历数组中的每一个数：

* 把窗口外的值从队尾中弹出（移动滑动窗口）
* 把小于当前值的元素从队首弹出（维护单调性质）
* 队尾的值就是当前滑动窗口的最大值


A题是POJ的经典题，值得一做。B题简单看一下即可，感觉有可能会被卡IO，敲了半天不能AC很囧。

## E题

E题属于单调队列加一点小trick的题。我们有两个单调队列统计最大值和最小值。当最大值和最小值的距离大于k时，我们弹出最旧的那个值，继续统计。

这里有个简单的结论，但是如果想不清楚就比较麻烦。即，一个子数组的最大最小值差小于m的时候，不需要弹出子数组中的任何数，因为弹出元素并不会让最大最小值差变的更大。

这题也可以用`multiset<int>`硬搞。

## D题、G题

D题的trick是在单调队列中存的是前辍和，而不是元素。

G题的队列的最旧值是区间最小值，因为一个小的高度乘以一个大的宽度，仍有可能是最大值。

D题可以用前辍和的RMQ。G题可以用RMQ+二分，求出一个起点能组成的最大矩形。

## C题、F题、H题
    
这三题放一起的，是因为它们都是DP的优化。

C题不是严格的单调队列。F题和H题都是单调队列优化:

```
foreach l <= r && r - l >= k:
    dp[i][r] = max(dp[i - 1][l] + r - l)
```

这些题的一个特点就是代码难写，Case难构造。所以遇到这种题最好的策略就是不写（

说正经的，最好的策略就是用心构造测试用例，多输出中间结果，多在代码级检查问题。

## 写在后面

人的大脑可以比喻成一个CPU+MEM的结构。最优的情况当然是大内存和快CPU同时工作。但是很多情况下只能二者取其一。

做一些比较复杂的DP题，因为细节很多，又要考虑整体的状态转移，所以对脑力是一种非常良好的锻炼。

同时，多进行这种锻炼还可以增强自信，这对解题，尤其是解难题也是有一定的帮助的。

> p.s. 觉得Github的Issues用来做记录与笔记真的非常适合，例如记录这组题目的[Issue][3]

## 请我喝一杯可乐

![](https://raw.githubusercontent.com/Inapt19/Resource/master/bonus_QR.jpg)
![](https://raw.githubusercontent.com/Inapt19/Resource/master/wechat_bonus_qr.jpg)

## 待字闺中算法讨论微信群

微信群算法讨论，娱乐比赛开黑等你加入。

![](https://raw.githubusercontent.com/Inapt19/Resource/master/wechat_QR.jpg)


[1]: https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/
[2]: https://vjudge.net/contest/164725#overview
[3]: https://github.com/Inapt19/Daiziguizhong/issues/22
