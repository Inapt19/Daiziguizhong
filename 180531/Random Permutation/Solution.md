本题的重点在于数据是**完全随机构造**的，也就是说每一个数字出现的位置是随机的。所以我们可以使用分治的方法来解题，而不用担心由于数据的倾斜导致的超时。

> 这里做个类比，快速排序对于随机构造的数据的时间复杂度是O(n * logn)。但是对于某些数据，会退化成O(n * n)。本题的数据就保证不会出现类似的退化。 

每一个子数组都有“最大值”和“最小值”起作用，所以我们可以对数组排序，从最小的开始，这样已经处理过的数据一定比当前的值小。

这点非常重要，如果之前的数比当前的数小，当前数“起做用”的区间，一定不能包含之前已经处理过的数。这就把整个数组分成了不联通的块，可以通过分治法来解决。

这样一来，我们就把之前的两个线索串到了一起。

每一次二分，我们都是找到当前（子）数组的最小值，然后在它的左右两边，分别从大到小进行依次遍历，并记录不同区间的“最大值”、“最小值”以及区间的记数。然后，把数组从最小值中间分割开，对两边的数组进行同样的操作就好。

本题还可以用RMQ做，这里不做讨论，理论上也应该是一种好做法。

## 请我喝一杯可乐

![](https://raw.githubusercontent.com/Inapt19/Resource/master/bonus_QR.jpg)
![](https://raw.githubusercontent.com/Inapt19/Resource/master/wechat_bonus_qr.jpg)

## 待字闺中微信群

内部测试期间，先加以下微信为好友，之后会把你拉入群中

![](https://raw.githubusercontent.com/Inapt19/Resource/master/wechat_QR.jpg)
