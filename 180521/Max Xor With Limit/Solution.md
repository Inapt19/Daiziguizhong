看到最大xor，就可以想到Trie树的经典做法：

1. 把整数补0转为二进制，这里我们转为32位整数（例如123，就会转化为`00000000000000000000000001111011`）
2. 把所有整数使用Trie树的形式组织起来（二叉Trie树，一个节点伸出0和1两条边）
3. 根据题目要求，遍历Trie树，获得最大的xor值

Trie树求最大XOR的基本原理是，在某一位上，如果我们选择走0这条边，那么在我们的结果中，这一位一定尽可能的选1，因为0 ^ 1 == 1；如果选择走1这条边，那我们要尽可能是在结果中把这一位置0。

又由于题目中有最大值的限制，所以贪心策略如下：

1. 如果某一位可以选择0或者1，一定选0，因为这样最后的值一定是最小的，一定最有可能符合要求
2. 如果某一位选1可以获得最大XOR，则判断已经选出的二进制前缀是否大于最大值的限制，如果大于，则只能选0

这种贪心的遍历算法是不需要回溯的，所以无论有多少个数，遍历一次的时间复杂度为O(h)。在本题中，h = 32。

所以建立Trie树的时间复杂度为O(n * h)，一次查询为O(h)。

## 请我喝一杯可乐

![](https://raw.githubusercontent.com/Inapt19/Resource/master/bonus_QR.jpg)
![](https://raw.githubusercontent.com/Inapt19/Resource/master/wechat_bonus_qr.jpg)

## 待字闺中微信群

内部测试期间，先加以下微信为好友，之后会把你拉入群中

![](https://raw.githubusercontent.com/Inapt19/Resource/master/wechat_QR.jpg)

